#! /usr/bin/env bash

: <<="cut"
=pod

=head1  NAME

oap - Fetch CDL element data via their API

=head1 SYNOPSIS

oap [-E|--endpoint=<CDL elements endpoint>] \
      [-S --http.session=<httpie session|default ucd>] \
      [-h|--help] <command> [<args>]

  where <command> is one of C<config> C<profiles> C<login> C<odr.departments> C<pps.divisions> C<pps.departments> C<pps.titles> C<sis.colleges> C<ids>

oap is as script that simplifies access to standard UC Davis identities.
oap also preforms some Aggie Expert specific functions, primarily
representing the api as linked data.

oap is a set of bash functions to communicate with the services.  oap uses
a few other tools to perform the functions. L</"COMMANDS"> is summary of the
commands that are available.

=head1 GLOBAL OPTIONS

=over 4

=item B<-S|--session|--http_session=I<http_session>>

Set the HTTPIE session variable.  For consistancy with other Aggie Expert tools,
the IAM authentication key is stored in a httpie session variable.  This is not
as useful as some other APIs, since the authentication method will not actually
work with UCD IAM api, which uses a parameter and not a header.  But, our
standard method allows users to maintain a persistant authentication, so we do
that here as well.

=item B<-h|--help>

Shows the manpage for the program. The help pages are embedded in the script and
require the functions, C<pod2usage> and C<pod2text> to work properly.

=back

=cut


: <<=cut
=head2 PREFIX

ucdid parse_url url

C<ucdid parse_url> returns a bash array of the passed parsed URL.  This really
just a diagnostic test to verify any urls are being read correctly.

=cut

function parse_url() {
  declare -A url

  url[endpoint]=$1
  [[ -n ${url[endpoint]} ]] || url[endpoint]="${G[endpoint]}"

  local pattern='^(([[:alnum:]]+):)(//((([[:alnum:]]+)(:([[:alnum:]]+))?@)?([^:^@^/]+)(:([[:digit:]]+))?)?)?/(\.)?(.*)?$'


  if [[ "${url[endpoint]}" =~ $pattern ]]; then
    url[is]="url"
    url[proto]=${BASH_REMATCH[2]}
    url[user]=${BASH_REMATCH[6]}
    url[password]=${BASH_REMATCH[8]}
    url[hostname]=${BASH_REMATCH[9]}
    url[port]=${BASH_REMATCH[11]}
    if [[ -n ${url[port]} ]]; then
      url[host]="${BASH_REMATCH[9]}:${BASH_REMATCH[11]}"
    else
      url[host]=${url[hostname]}
    fi
    if [[ -n ${BASH_REMATCH[12]} ]] ; then
      url[path]="${BASH_REMATCH[12]}${BASH_REMATCH[13]}"
    else
      url[path]="/${BASH_REMATCH[13]}"
    fi
  else
    url[proto]="file";
    url[path]=${PWD}/${url[endpoint]}
  fi

  declare -p url
}


function main.init() {
  local opts;
    if ! opts=$(${G[shell_getopt]} -o E:bnhS:v --long endpoint:,prefix:,no-default-prefix,verbose,http_session:,session:,help -n "oap" -- "$@"); then
    echo "Bad Command Options." >&2 ; exit 1 ; fi

    log $opts
    eval set -- "$opts"

    declare -A CMD;
    while true; do
	    case $1 in
        -E | --endpoint ) CMD[endpoint]=$2; shift 2;;
	      --session | --http_session) CMD[http_session]=$2;  shift 2;;
	      -v | --verbose) CMD[verbose]+="v";  shift;;
	      --print | --http_print) CMD[http_print]=$2; shift 2;;
        -h | --help ) exec pod2text "$0";;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    local config
    # Read the configuration file(s)
    for config in ${G[aeq_home]}/config/aeq.yml \
                  ${G[home]}/.config/aeq/aeq.yml ./.aeq.yml; do
      if [[ -f $config ]]; then
        eval "$(_parse_yaml "$config")"
      fi
    done

    # system variables (OAP_FOO_BAR) over config file
    for i in "${!G[@]}"; do
      local v=''
      eval v="\$OAP_${i^^}"
      [[ -n "$v" ]] && G["$i"]="$v"
    done

    # command line over config and over system var
    for i in "${!CMD[@]}"; do
      [[ -n ${CMD[$i]} ]] && G[$i]=${CMD[$i]};
    done

}

: <<='cut'
=pod

=head1 COMMANDS

C<oap config> will show all the parameters for the command.

C<oap login --auth=I<authentication>> sets the authentication key, and needs
to be run before the other commands can be run.

C<oap fetch --auth=I<authentication> [--format=I<mime/type>]
[--context=I<context_string>] [--envelope] I<data_files>> fetches the required
datafiles from the system.

=cut

function main.cmd () {
    cmd=$1
    shift;
    case $cmd in
	    login ) # authentication
	      $cmd "$@";
	      ;;
      config ) # informational requests
        declare -p G
        ;;
	    fetch|parse_url) # utility functions
	      $cmd "$@";
	      ;;
	    *)
	      exec pod2usage "$0"
	  ;;
    esac
}

function log() {
  if [[ $1 = '-v' ]]; then
    shift
    if [[ ${G[verbose]} ]]; then
      echo -e >&2 LOG -V: "${@:-$(</dev/stdin)}"
    fi
  else
    echo -e >&2 LOG: "${@:-$(</dev/stdin)}"
  fi
}

function err() {
  local n=1;
  if [[ $1 = '--quiet' ]] ; then
    n=$2;
  else
    n=$1
    shift
    (>&2 echo err: "$@")
  fi
  exit "$n";
}

: <<='cut'

=head2 LOGIN

  oap login --auth=USER[:PASS]

B<ucd login> allows the user to persist their authentication.  These stores the
  authorization in the C<httpie> session parameters.  Typically the session
  variables are stored in the container and will be reset whenever the container
  is restarted from a fresh instance.

  login --session=ucd login --auth=ucd:

After which the session C<ucd>, will be set as a httpie session, with
the saved authorization.

=head3 LOGIN OPTIONS

=over 4

=item B<-a|--auth=USER:PASS>

You specify the basic authentication for the server. For iam, the user does not
matter, and the PASS is passed as the key for the

=back

=cut

function login() {
  local opts;
  if ! opts=$(${G[shell_getopt]} -o a --long auth: -n "oap login" -- "$@"); then
    echo "Bad Command Options." >&2 ; exit 1 ; fi

    eval set -- "$opts"

    local auth=
    local key=

    while true; do
	    case $1 in
        -a | --auth ) auth=$2; shift 2;;
	      -- ) shift; break;;
	      *) shift; break;
      esac
    done

    local http="${G[util_http]} --check-status --session=${G[http_session]} --auth=${auth} --print=hH"
    $http "${G[endpoint]}/groups"
}


: <<=cut

=head2 FETCH COMMANDS

 Most commands simply fetch a particular dataset via the elements API.  These
 are: C<users> C<groups> C<journals> C<publications>
 C<pps.titles> C<sis.colleges> C<ids>.  Every command has the following parameters


=over 4

=item B<-f|--format=I<mime/type>>

Specify the format for the return. This is in mime/type, and must be one of
C<application/json> C<application/ld+json> or C<text/turtle>.  These can also be short
hand C<json>,C<jsonld> or C<turtle|ttl>.  The default is C<application/json>

=item B<-c|--context=I<string>>

For C<application/ld+json> and C<text/turtle>, you can specify a custom context
to be added to the system.

=item B<--envelope>

For consistancy between all formats, only the response data is returned.  If you
are specifing C<application/json> data, you may use this flag to get the complete
response.

=back

=cut
function fetch() {
  local opts;

  declare -A url=(
    [identifiers]="${G[endpoint]}/user/identifiers"
    [groups]="${G[endpoint]}/groups"
    [users]="${G[endpoint]}/users"
    );

  declare -A mime=(
    ['application/atom+xml']='application/atom+xml'
    ['xml']='application/atom+xml'
    ['application/ld+json']='application/ld+json'
    ['text/turtle']='text/turtle'
    ['application/json']='application/json'
    [jsonld]='application/ld+json'
    [turtle]='text/turtle'
    [ttl]='text/turtle'
    [json]='application/json'
  );

  declare -A entry=(
    [identifiers]='api:object'
    [user]='api:object'
    [publication]='api:object'
    [relationship]='api:relationship'
    [group]='api:user-group'
  );

  if ! opts=$(${G[shell_getopt]} -o A:bnhs:vo: --long output:,format:,context:,envelope,search: -n "oap elements" -- "$@"); then
    echo "Bad Command Options." >&2 ; exit 1 ; fi

  eval set -- "$opts"

  local search=''
  local output=/dev/stdout
  declare -A CMD=(
    [format]="xml"
  );
  local compress=''
  while true; do
	  case $1 in
      -f | --format) CMD[fetch_format]=$2; shift 2;;
      -c | --context) CMD[fetch_context]=$2; shift 2;;
      -z | --compress) CMD[fetch_compress]=1; shift;;
      -s | --search) search=$2; shift 2;;
      -o | --output) [[ $2 != '-' ]] && output=$2; shift 2;;
	    -- ) shift; break;;
	    *) shift; break;
    esac
  done

  # command line over config and over system var
  for i in "${!CMD[@]}"; do
    [[ -n ${CMD[$i]} ]] && G[$i]=${CMD[$i]};
  done

  # Get the key
  local key=undefined
  # Elements key from the session variable
  local inp
  inp=$(parse_url ${G[endpoint]})
  declare -A ep=()
  eval "declare -A ep=${inp#*=}"
  local json="$HOME/.httpie/sessions/${ep[hostname]}"
  [[ -n ${ep[port]} ]] && json+=_${ep[port]}
  json+=/${G[http_session]}.json

  if [[ -n ${ep[password]} ]]; then
    key=${ep[password]};
  elif [[ -f $json ]]; then
    key=$(${G[util_jq]} -r .auth.raw_auth "$json")
    key=${key#*:}
  fi

  # Now look only at "$1"
  if [[ -z ${url[$1]} ]] ; then
    err 1 "$1 is not one of:" "${!url[@]}"
  fi

  # Check format
  [[ -z ${mime["${G[fetch_format]}"]} ]] && err 1 "${G[fetch_format]} is invalid format"
  elements="http --session-read-only=${G[http_session]} ${url[$1]}"
  if [[ "$1" == "profiles" ]]; then
    search=$(sed -e 's/\([^=]\)=\([^=]\)/\1==\2/g' <<<"$search")
    elements+=" ${search}"
  fi
  log -v "${elements} |"
  ${elements} |
    if [[ ${mime[${G[fetch_format]}]} = "application/atom+xml" ]]; then
      cat - > "${output}"
    else  # Everything below to json...
      log "${G[util_xml2json]}" /dev/stdin ' | ' "${G[util_jq]} .entry[\"${entry[$1]}\"]" ' | '
      ${G[util_xml2json]} /dev/stding | ${G[util_jq]} ".entry[\"${entry[$1]}\"]" |
        if [[ "${mime[${G[fetch_format]}]}" != "application/json" ]]; then
          ${G[util_jq]} "${G[fetch_context]}"' + {"@graph":(.[]|=with_entries(if .key=="id" then .key="@id" else . end))}'
        fi |
        if [[ "${mime[${G[fetch_format]}]}" == "text/turtle" ]]; then
          ${G[util_riot]} --formatted=ttl --syntax=jsonld
        fi
    fi |
  if [[ "$compress" ]]; then
    gzip > "$output"
  else
    cat - > "$output"
  fi
}

: <<=cut
=pod


=head1 AUTHOR

Quinn Hart <qjhart@ucdavis.edu>

=cut


#MAIN
# global Variables
declare -A G=(
  [cmd]=$(basename $0)
  [endpoint]='https://oapolicy.universityofcalifornia.edu:8002/elements-secure-api/v5.5'
  [base]='http://experts.ucdavis.edu/oap/'
  [fetch_format]='xml'
  [http_session]="ucd"
  [util_http]="http"
  [util_jq]="jq"
  [util_xml2json]="xml2json"
  [util_riot]="riot"
  [home]="$( cd "$( dirname "${BASH_SOURCE[0]}" )/../lib/harvest" >/dev/null 2>&1 && pwd )"
);


G[fetch_context]='{"@context":{
"@base":"http://experts.ucdavis.edu/oap/",
"@vocab":"http://experts.ucdavis.edu/oap/vocab#",
"oap":"http://experts.ucdavis.edu/oap/vocab#",
"api":"http://experts.ucdavis.edu/oap/vocab#",
"id":{"@type":"@id"},
"field-name":"api:field-name",
"field-number":"api:field-number",
"$$t":"api:field-value"}
}'


OPTS=();
# This command runs until the first '-'prefixed parameter.
while true; do
	case $1 in
	  -*) OPTS+=("$1"); shift ;;
#	  -- ) shift; break;;
	  *) break;
	esac
done

# Allow getopt to be somewhere else
G[shell_getopt]=${FLAGS_GETOPT_CMD:-getopt}

#log "${OPTS[@]}"
main.init "${OPTS[@]}"
main.cmd "$@"

exit 0;
